<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü–∏–Ω-–ü–æ–Ω–≥</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; }
        body { background: #000; display: flex; justify-content: center; align-items: center; min-height: 100vh; overflow: hidden; }
        canvas { display: block; border: none; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="endScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; flex-direction: column; justify-content: center; align-items: center; color: #fff; z-index: 20; font-family: monospace;">
        <div style="font-size: 48px; margin-bottom: 20px;">Good!</div>
        <button onclick="startGame()" style="background: #fff; color: #000; border: none; padding: 12px 30px; font-size: 18px; margin-top: 30px; cursor: pointer; font-family: monospace;">Restart</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const endScreen = document.getElementById('endScreen');

        canvas.width = 780;
        canvas.height = 580;

        // –ê—É–¥–∏–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let audioContext;
        let soundEnabled = true;
        let bgMusic;
        let redModeAudio;

        // –ó–≤—É–∫–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
        const sounds = {
            bounce: null,
            brickBreak: null,
            bulletSpawn: null,
            gameOver: null,
            victory: null,
            platformHit: null
        };

        let gameState = {
            isRunning: false,
            brokenBricks: 0,
            totalBricks: 25,
            isRedMode: false,
            gameOver: false,
            screenShake: 0
        };

        let platform = {
            x: 340,
            y: 530,
            width: 100,
            height: 15,
            color: '#fff',
            isDragging: false
        };

        let ball = {
            x: 390,
            y: 290,
            radius: 8,
            speedX: 0,
            speedY: 0,
            color: '#fff',
            launched: false
        };

        let bricks = [];
        let bullets = [];

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—É–¥–∏–æ
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                createSounds();
                
                bgMusic = createBackgroundMusic();
                
                redModeAudio = new Audio();
                redModeAudio.src = 'hardpong.mp3';
                redModeAudio.loop = true;
                redModeAudio.volume = 0.7;
                redModeAudio.preload = 'auto';
                
                const enableAudio = () => {
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    document.removeEventListener('click', enableAudio);
                    document.removeEventListener('touchstart', enableAudio);
                };
                
                document.addEventListener('click', enableAudio);
                document.addEventListener('touchstart', enableAudio);
            } catch (e) {
                console.log("–ê—É–¥–∏–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è:", e);
                soundEnabled = false;
            }
        }

        function createBackgroundMusic() {
            if (!soundEnabled) return null;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            
            return { oscillator, gainNode };
        }

        function createSounds() {
            sounds.bounce = () => {
                if (!soundEnabled) return;
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400 + Math.random() * 200, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
            };

            sounds.brickBreak = () => {
                if (!soundEnabled) return;
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.3);
            };

            sounds.bulletSpawn = () => {
                if (!soundEnabled) return;
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);
            };

            sounds.platformHit = () => {
                if (!soundEnabled) return;
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(200 + Math.random() * 100, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.25, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.15);
            };

            sounds.gameOver = () => {
                if (!soundEnabled) return;
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
                
                gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.5);
            };

            sounds.victory = () => {
                if (!soundEnabled) return;
                
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        const notes = [523.25, 659.25, 783.99];
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(notes[i], audioContext.currentTime);
                        
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.5);
                    }, i * 150);
                }
            };
        }

        function switchMusic(toRedMode) {
    if (!soundEnabled) return;
    
    // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–∫—É—â—É—é –º—É–∑—ã–∫—É
    if (bgMusic && bgMusic.gainNode) {
        bgMusic.gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        setTimeout(() => {
            if (bgMusic.oscillator) {
                bgMusic.oscillator.stop();
            }
        }, 500);
    }
    
    if (redModeAudio && !toRedMode) {
        redModeAudio.pause();
        redModeAudio.currentTime = 0;
    }
    
    setTimeout(() => {
        if (toRedMode) {
            // –ü—Ä–æ–±—É–µ–º –∑–∞–ø—É—Å—Ç–∏—Ç—å hardpong.mp3
            redModeAudio.currentTime = 0;
            redModeAudio.play().catch(e => {
                console.log("–ú—É–∑—ã–∫–∞ –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è –ø—Ä–∏ —Å–ª–µ–¥—É—é—â–µ–º –∫–ª–∏–∫–µ");
                // –ï—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å - –ø–æ–º–µ—Ç–∏–º —á—Ç–æ –Ω—É–∂–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ–∑–∂–µ
                window.needToPlayRedMusic = true;
            });
        } else {
            bgMusic = createBackgroundMusic();
            bgMusic.gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
        }
    }, 500);
}

        function initBricks() {
            bricks = [];
            const rows = 5;
            const cols = 5;
            const brickWidth = 60;
            const brickHeight = 20;
            const padding = 10;
            const offsetX = (canvas.width - (cols * brickWidth + (cols - 1) * padding)) / 2;
            const offsetY = 50;
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    bricks.push({
                        x: offsetX + c * (brickWidth + padding),
                        y: offsetY + r * (brickHeight + padding),
                        width: brickWidth,
                        height: brickHeight,
                        color: '#fff',
                        isBroken: false
                    });
                }
            }
        }

        function createBullet() {
            const speed = 8;
            const size = 10;
            
            const x = Math.random() * canvas.width;
            const y = 0;
            const speedX = (Math.random() - 0.5) * 3;
            const speedY = speed;
            
            if (gameState.isRedMode && soundEnabled && sounds.bulletSpawn) {
                sounds.bulletSpawn();
            }
            
            bullets.push({
                x: x,
                y: y,
                width: size,
                height: size,
                speedX: speedX,
                speedY: speedY,
                color: '#ff0000'
            });
        }

        function clearBullets() {
            bullets = bullets.filter(bullet => 
                bullet.x > -100 && bullet.x < canvas.width + 100 && 
                bullet.y > -100 && bullet.y < canvas.height + 100
            );
        }

        function update() {
            if (!gameState.isRunning || gameState.gameOver) return;

            if (ball.launched) {
                ball.x += ball.speedX;
                ball.y += ball.speedY;

                // –£–∑–∫–∏–µ –ª–µ–≤—ã–µ –∏ –ø—Ä–∞–≤—ã–µ —Å—Ç–µ–Ω—ã (—Ç–æ–ª—å–∫–æ 2px —Å –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã)
                const sideWallMargin = 2; // –û—á–µ–Ω—å —É–∑–∫–∏–µ –±–æ–∫–æ–≤—ã–µ —Å—Ç–µ–Ω—ã
                const topWallMargin = 5;
                const bottomWallMargin = 5;
                
                // –û—Ç—Å–∫–æ–∫ –æ—Ç –ª–µ–≤–æ–π –∏ –ø—Ä–∞–≤–æ–π —Å—Ç–µ–Ω (—É–∑–∫–∏–µ)
                if (ball.x - ball.radius <= sideWallMargin || ball.x + ball.radius >= canvas.width - sideWallMargin) {
                    ball.speedX = -ball.speedX;
                    if (soundEnabled && sounds.bounce) sounds.bounce();
                }
                
                // –û—Ç—Å–∫–æ–∫ –æ—Ç –≤–µ—Ä—Ö–Ω–µ–π —Å—Ç–µ–Ω—ã
                if (ball.y - ball.radius <= topWallMargin) {
                    ball.speedY = -ball.speedY;
                    if (soundEnabled && sounds.bounce) sounds.bounce();
                }

                // –ü—Ä–æ–∏–≥—Ä—ã—à –ø—Ä–∏ –∫–∞—Å–∞–Ω–∏–∏ –Ω–∏–∂–Ω–µ–π —Å—Ç–µ–Ω—ã
                if (ball.y + ball.radius >= canvas.height - bottomWallMargin) {
                    if (soundEnabled && sounds.gameOver) sounds.gameOver();
                    gameOver();
                    return;
                }

                // –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∞ –≤—ã—Å–æ—Ç–æ–π
                const maxPlatformY = canvas.height / 2 + 50;
                
                if (ball.x + ball.radius >= platform.x && 
                    ball.x - ball.radius <= platform.x + platform.width &&
                    ball.y + ball.radius >= platform.y && 
                    ball.y - ball.radius <= platform.y + platform.height) {
                    
                    const hitPoint = (ball.x - platform.x) / platform.width;
                    const angle = hitPoint * Math.PI - Math.PI / 2;
                    const speed = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY);
                    const newSpeed = Math.min(speed * 1.05, 8);
                    
                    ball.speedX = Math.sin(angle) * newSpeed;
                    ball.speedY = -Math.cos(angle) * newSpeed;
                    
                    ball.y = platform.y - ball.radius;
                    
                    if (soundEnabled && sounds.platformHit) sounds.platformHit();
                }

                for (let brick of bricks) {
                    if (!brick.isBroken && 
                        ball.x + ball.radius >= brick.x && 
                        ball.x - ball.radius <= brick.x + brick.width &&
                        ball.y + ball.radius >= brick.y && 
                        ball.y - ball.radius <= brick.y + brick.height) {
                        
                        brick.isBroken = true;
                        gameState.brokenBricks++;
                        
                        if (soundEnabled && sounds.brickBreak) sounds.brickBreak();
                        
                        const ballLeft = ball.x - ball.radius;
                        const ballRight = ball.x + ball.radius;
                        const ballTop = ball.y - ball.radius;
                        const ballBottom = ball.y + ball.radius;
                        
                        const brickLeft = brick.x;
                        const brickRight = brick.x + brick.width;
                        const brickTop = brick.y;
                        const brickBottom = brick.y + brick.height;
                        
                        const overlapLeft = ballRight - brickLeft;
                        const overlapRight = brickRight - ballLeft;
                        const overlapTop = ballBottom - brickTop;
                        const overlapBottom = brickBottom - ballTop;
                        
                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                        
                        if (minOverlap === overlapLeft) {
                            ball.speedX = -Math.abs(ball.speedX);
                        } else if (minOverlap === overlapRight) {
                            ball.speedX = Math.abs(ball.speedX);
                        } else if (minOverlap === overlapTop) {
                            ball.speedY = -Math.abs(ball.speedY);
                        } else if (minOverlap === overlapBottom) {
                            ball.speedY = Math.abs(ball.speedY);
                        }
                        
                        if (gameState.brokenBricks === 6 && !gameState.isRedMode) {
                            activateRedMode();
                        }
                        
                        if (gameState.brokenBricks === gameState.totalBricks) {
                            if (soundEnabled && sounds.victory) sounds.victory();
                            victory();
                        }
                        
                        break;
                    }
                }
            }

            if (gameState.isRedMode) {
                for (let bullet of bullets) {
                    bullet.x += bullet.speedX;
                    bullet.y += bullet.speedY;
                    
                    if (bullet.x + bullet.width >= platform.x && 
                        bullet.x <= platform.x + platform.width &&
                        bullet.y + bullet.height >= platform.y && 
                        bullet.y <= platform.y + platform.height) {
                        
                        if (soundEnabled && sounds.gameOver) sounds.gameOver();
                        gameOver();
                        return;
                    }
                }
                
                if (Math.random() < 0.1) {
                    createBullet();
                }
                
                clearBullets();
                
                if (gameState.screenShake > 0) {
                    gameState.screenShake--;
                }
            }
        }

        function activateRedMode() {
            gameState.isRedMode = true;
            gameState.screenShake = 100;
            platform.color = '#ff66cc';
            ball.color = '#ff88ee';
            
            switchMusic(true);
            
            for (let i = 0; i < 10; i++) {
                setTimeout(() => createBullet(), i * 100);
            }
        }

        function gameOver() {
            gameState.gameOver = true;
            gameState.isRunning = false;
            
            if (bgMusic && bgMusic.oscillator) {
                bgMusic.oscillator.stop();
            }
            if (redModeAudio) {
                redModeAudio.pause();
                redModeAudio.currentTime = 0;
            }
            
            setTimeout(() => {
                endScreen.style.display = 'flex';
                document.querySelector('#endScreen div').textContent = 'Game Over';
            }, 500);
        }

        function victory() {
            gameState.gameOver = true;
            gameState.isRunning = false;
            
            if (bgMusic && bgMusic.oscillator) {
                bgMusic.oscillator.stop();
            }
            if (redModeAudio) {
                redModeAudio.pause();
                redModeAudio.currentTime = 0;
            }
            
            setTimeout(() => {
                endScreen.style.display = 'flex';
                document.querySelector('#endScreen div').textContent = 'Good!';
            }, 500);
        }

        function draw() {
            let shakeX = 0;
            let shakeY = 0;
            
            if (gameState.screenShake > 0) {
                shakeX = (Math.random() - 0.5) * 10;
                shakeY = (Math.random() - 0.5) * 10;
            }
            
            // –ß—ë—Ä–Ω—ã–π —Ñ–æ–Ω
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // –¢–æ–Ω–∫–∏–µ –±–æ–∫–æ–≤—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã - —É–∑–∫–∏–µ —Å—Ç–µ–Ω—ã
            ctx.fillStyle = '#222';
            // –õ–µ–≤–∞—è —Å—Ç–µ–Ω–∞ (—É–∑–∫–∞—è)
            ctx.fillRect(0, 0, 2, canvas.height);
            // –ü—Ä–∞–≤–∞—è —Å—Ç–µ–Ω–∞ (—É–∑–∫–∞—è)
            ctx.fillRect(canvas.width - 2, 0, 2, canvas.height);
            // –í–µ—Ä—Ö–Ω—è—è –∏ –Ω–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü—ã (–Ω–æ—Ä–º–∞–ª—å–Ω—ã–µ)
            ctx.fillRect(0, 0, canvas.width, 5);
            ctx.fillRect(0, canvas.height - 5, canvas.width, 5);
            
            // –ü—É–Ω–∫—Ç–∏—Ä–Ω–∞—è –ª–∏–Ω–∏—è –ø–æ—Å–µ—Ä–µ–¥–∏–Ω–µ
            ctx.strokeStyle = gameState.isRedMode ? '#660000' : '#333';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.save();
            ctx.translate(shakeX, shakeY);
            
            for (let brick of bricks) {
                if (!brick.isBroken) {
                    ctx.fillStyle = gameState.isRedMode ? '#ff6666' : '#fff';
                    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    
                    ctx.strokeStyle = gameState.isRedMode ? '#ff0000' : '#ccc';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                }
            }
            
            // –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞
            ctx.fillStyle = platform.color;
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            
            // –ü–∏–∫—Å–µ–ª–∏ –Ω–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ
            ctx.fillStyle = gameState.isRedMode ? '#ff6666' : '#ccc';
            for (let i = 0; i < 6; i++) {
                ctx.fillRect(platform.x + 8 + i * 14, platform.y + 4, 8, 3);
            }
            
            // –ú—è—á
            ctx.fillStyle = ball.color;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = gameState.isRedMode ? '#ff0000' : '#888';
            ctx.beginPath();
            ctx.arc(ball.x - 2, ball.y - 2, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // –ü—É–ª–∏ –≤ –∫—Ä–∞—Å–Ω–æ–º —Ä–µ–∂–∏–º–µ
            if (gameState.isRedMode) {
                for (let bullet of bullets) {
                    ctx.fillStyle = bullet.color;
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    
                    ctx.fillStyle = '#ff6666';
                    ctx.fillRect(bullet.x + 2, bullet.y + 2, bullet.width - 4, bullet.height - 4);
                }
                
                if (gameState.screenShake > 0) {
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.15)';
                    ctx.lineWidth = 1;
                    
                    for (let x = 0; x < canvas.width; x += 25) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y < canvas.height; y += 25) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }
                }
            }
            
            ctx.restore();
        }

        function gameLoop() {
            update();
            draw();
            
            if (gameState.isRunning && !gameState.gameOver) {
                requestAnimationFrame(gameLoop);
            }
        }

        function launchBall() {
            if (!ball.launched) {
                ball.launched = true;
                ball.speedX = 6 * (Math.random() > 0.5 ? 1 : -1);
                ball.speedY = -6;
                
                if (soundEnabled && sounds.bounce) sounds.bounce();
            }
        }

        function handleMouseMove(e) {
            if (!gameState.isRunning || gameState.gameOver) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            let mouseX = (e.clientX - rect.left) * scaleX;
            let mouseY = (e.clientY - rect.top) * scaleY;
            
            const maxY = canvas.height / 2 + 30;
            mouseX = Math.max(platform.width / 2, Math.min(canvas.width - platform.width / 2, mouseX));
            mouseY = Math.max(maxY, Math.min(canvas.height - platform.height / 2, mouseY));
            
            if (platform.isDragging) {
                platform.x = mouseX - platform.width / 2;
                platform.y = mouseY - platform.height / 2;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!gameState.isRunning || gameState.gameOver) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const touch = e.touches[0];
            let touchX = (touch.clientX - rect.left) * scaleX;
            let touchY = (touch.clientY - rect.top) * scaleY;
            
            const maxY = canvas.height / 2 + 30;
            touchX = Math.max(platform.width / 2, Math.min(canvas.width - platform.width / 2, touchX));
            touchY = Math.max(maxY, Math.min(canvas.height - platform.height / 2, touchY));
            
            platform.x = touchX - platform.width / 2;
            platform.y = touchY - platform.height / 2;
            
            launchBall();
        }

        function narrowSideWalls() {
    console.log("üöÄ –ó–∞–ø—É—Å–∫ —Ñ—É–Ω–∫—Ü–∏–∏ —Å—É–∂–µ–Ω–∏—è –±–æ–∫–æ–≤—ã—Ö —Å—Ç–µ–Ω - —Å—Ç–∏–ª—å–Ω—ã–µ —Å–µ—Ä—ã–µ —Å—Ç–µ–Ω—ã!");
    
    // 1. –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å—É–∂–µ–Ω–∏—è (—à–∏—Ä–µ —á–µ–º –±—ã–ª–æ)
    const originalWidth = canvas.width;
    const narrowingAmount = 80; // –ë—ã–ª–æ 100, —Ç–µ–ø–µ—Ä—å 150 - —à–∏—Ä–µ –Ω–∞ 50px
    const newLeftWall = narrowingAmount;
    const newRightWall = originalWidth - narrowingAmount;
    
    console.log(`üìè –°—É–∂–∞–µ–º —Å—Ç–µ–Ω—ã –Ω–∞ ${narrowingAmount}px —Å –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã (—à–∏—Ä–µ —á–µ–º —Ä–∞–Ω—å—à–µ!)`);
    console.log(`üìê –ù–æ–≤—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã: ${newLeftWall}px ‚Üê –∏–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ ‚Üí ${newRightWall}px`);
    console.log(`üìä –ù–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä –ø–æ–ª—è: ${newRightWall - newLeftWall}px (–±—ã–ª–æ ${originalWidth}px)`);
    
    // 2. –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é update() –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—É–∂–µ–Ω–Ω—ã—Ö —Å—Ç–µ–Ω
    const originalUpdate = window.update;
    
    window.update = function() {
        if (!gameState.isRunning || gameState.gameOver) return;

        if (ball.launched) {
            ball.x += ball.speedX;
            ball.y += ball.speedY;

            const wallThickness = 2; // –¢–æ–Ω–∫–∏–µ —Å—Ç–µ–Ω—ã –∫–∞–∫ –≤–µ—Ä—Ö –∏ –Ω–∏–∑
            const topWallMargin = 5;
            const bottomWallMargin = 5;
            
            // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å —Å—É–∂–µ–Ω–Ω—ã–º–∏ —Å—Ç–µ–Ω–∞–º–∏ (—Ç–æ–Ω–∫–∏–º–∏)
            if (ball.x - ball.radius <= newLeftWall + wallThickness || 
                ball.x + ball.radius >= newRightWall - wallThickness) {
                ball.speedX = -ball.speedX;
                console.log(`‚öΩ –û—Ç—Å–∫–æ–∫ –æ—Ç —Ç–æ–Ω–∫–æ–π —Å—Ç–µ–Ω—ã: x=${ball.x.toFixed(1)}`);
                if (soundEnabled && sounds.bounce) sounds.bounce();
            }
            
            if (ball.y - ball.radius <= topWallMargin) {
                ball.speedY = -ball.speedY;
                if (soundEnabled && sounds.bounce) sounds.bounce();
            }

            if (ball.y + ball.radius >= canvas.height - bottomWallMargin) {
                if (soundEnabled && sounds.gameOver) sounds.gameOver();
                gameOver();
                return;
            }

            const maxPlatformY = canvas.height / 2 + 50;
            
            if (ball.x + ball.radius >= platform.x && 
                ball.x - ball.radius <= platform.x + platform.width &&
                ball.y + ball.radius >= platform.y && 
                ball.y - ball.radius <= platform.y + platform.height) {
                
                const hitPoint = (ball.x - platform.x) / platform.width;
                const angle = hitPoint * Math.PI - Math.PI / 2;
                const speed = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY);
                const newSpeed = Math.min(speed * 1.05, 8);
                
                ball.speedX = Math.sin(angle) * newSpeed;
                ball.speedY = -Math.cos(angle) * newSpeed;
                
                ball.y = platform.y - ball.radius;
                
                if (soundEnabled && sounds.platformHit) sounds.platformHit();
            }

            for (let brick of bricks) {
                if (!brick.isBroken && 
                    ball.x + ball.radius >= brick.x && 
                    ball.x - ball.radius <= brick.x + brick.width &&
                    ball.y + ball.radius >= brick.y && 
                    ball.y - ball.radius <= brick.y + brick.height) {
                    
                    brick.isBroken = true;
                    gameState.brokenBricks++;
                    
                    if (soundEnabled && sounds.brickBreak) sounds.brickBreak();
                    
                    const ballLeft = ball.x - ball.radius;
                    const ballRight = ball.x + ball.radius;
                    const ballTop = ball.y - ball.radius;
                    const ballBottom = ball.y + ball.radius;
                    
                    const brickLeft = brick.x;
                    const brickRight = brick.x + brick.width;
                    const brickTop = brick.y;
                    const brickBottom = brick.y + brick.height;
                    
                    const overlapLeft = ballRight - brickLeft;
                    const overlapRight = brickRight - ballLeft;
                    const overlapTop = ballBottom - brickTop;
                    const overlapBottom = brickBottom - ballTop;
                    
                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                    
                    if (minOverlap === overlapLeft) {
                        ball.speedX = -Math.abs(ball.speedX);
                    } else if (minOverlap === overlapRight) {
                        ball.speedX = Math.abs(ball.speedX);
                    } else if (minOverlap === overlapTop) {
                        ball.speedY = -Math.abs(ball.speedY);
                    } else if (minOverlap === overlapBottom) {
                        ball.speedY = Math.abs(ball.speedY);
                    }
                    
                    if (gameState.brokenBricks === 6 && !gameState.isRedMode) {
                        activateRedMode();
                    }
                    
                    if (gameState.brokenBricks === gameState.totalBricks) {
                        if (soundEnabled && sounds.victory) sounds.victory();
                        victory();
                    }
                    
                    break;
                }
            }
        }

        if (gameState.isRedMode) {
            for (let bullet of bullets) {
                bullet.x += bullet.speedX;
                bullet.y += bullet.speedY;
                
                // –ü—É–ª–∏ –æ—Ç—Å–∫–∞–∫–∏–≤–∞—é—Ç –æ—Ç —Å—É–∂–µ–Ω–Ω—ã—Ö —Å—Ç–µ–Ω
                if (bullet.x < newLeftWall || bullet.x + bullet.width > newRightWall) {
                    bullet.speedX = -bullet.speedX;
                }
                
                if (bullet.x + bullet.width >= platform.x && 
                    bullet.x <= platform.x + platform.width &&
                    bullet.y + bullet.height >= platform.y && 
                    bullet.y <= platform.y + platform.height) {
                    
                    if (soundEnabled && sounds.gameOver) sounds.gameOver();
                    gameOver();
                    return;
                }
            }
            
            if (Math.random() < 0.1) {
                createBullet();
            }
            
            clearBullets();
            
            if (gameState.screenShake > 0) {
                gameState.screenShake--;
            }
        }
    };
    
    console.log("‚úÖ –§—É–Ω–∫—Ü–∏—è update() –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –¥–ª—è —Ç–æ–Ω–∫–∏—Ö —Å—Ç–µ–Ω");

    // 3. –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é draw() –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ —Ç–æ–Ω–∫–∏—Ö —Å–µ—Ä—ã—Ö —Å—Ç–µ–Ω
    const originalDraw = window.draw;
    
    window.draw = function() {
        let shakeX = 0;
        let shakeY = 0;
        
        if (gameState.screenShake > 0) {
            shakeX = (Math.random() - 0.5) * 10;
            shakeY = (Math.random() - 0.5) * 10;
        }
        
        // –ß—ë—Ä–Ω—ã–π —Ñ–æ–Ω
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // –¢–û–ù–ö–ò–ï –°–ï–†–´–ï –°–¢–ï–ù–´ –∫–∞–∫ –≤–µ—Ä—Ö –∏ –Ω–∏–∑
        const wallColor = '#333333'; // –¢–∞–∫–æ–π –∂–µ —Å–µ—Ä—ã–π –∫–∞–∫ –≤–µ—Ä—Ö/–Ω–∏–∑
        const wallThickness = 2; // –¢–æ–Ω–∫–∏–µ –∫–∞–∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Å—Ç–µ–Ω—ã
        
        // –õ–µ–≤–∞—è —Å—Ç–µ–Ω–∞ (—Ç–æ–Ω–∫–∞—è —Å–µ—Ä–∞—è)
        ctx.fillStyle = wallColor;
        ctx.fillRect(newLeftWall, 0, wallThickness, canvas.height);
        
        // –ü—Ä–∞–≤–∞—è —Å—Ç–µ–Ω–∞ (—Ç–æ–Ω–∫–∞—è —Å–µ—Ä–∞—è) 
        ctx.fillStyle = wallColor;
        ctx.fillRect(newRightWall - wallThickness, 0, wallThickness, canvas.height);
        
        // –í–µ—Ä—Ö–Ω—è—è –∏ –Ω–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü—ã (—Ç–∞–∫–∏–µ –∂–µ —Ç–æ–Ω–∫–∏–µ)
        ctx.fillStyle = wallColor;
        ctx.fillRect(0, 0, canvas.width, wallThickness);
        ctx.fillRect(0, canvas.height - wallThickness, canvas.width, wallThickness);
        
        // –ü—É–Ω–∫—Ç–∏—Ä–Ω–∞—è –ª–∏–Ω–∏—è –ø–æ—Å–µ—Ä–µ–¥–∏–Ω–µ
        ctx.strokeStyle = gameState.isRedMode ? '#660000' : '#333';
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.moveTo(0, canvas.height / 2);
        ctx.lineTo(canvas.width, canvas.height / 2);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.save();
        ctx.translate(shakeX, shakeY);
        
        for (let brick of bricks) {
            if (!brick.isBroken) {
                // –°–∫—Ä—ã–≤–∞–µ–º –∫–∏—Ä–ø–∏—á–∏ –∑–∞ —Å—É–∂–µ–Ω–Ω—ã–º–∏ –≥—Ä–∞–Ω–∏—Ü–∞–º–∏
                if (brick.x + brick.width < newLeftWall + wallThickness || 
                    brick.x > newRightWall - wallThickness) {
                    continue;
                }
                
                ctx.fillStyle = gameState.isRedMode ? '#ff6666' : '#fff';
                ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                
                ctx.strokeStyle = gameState.isRedMode ? '#ff0000' : '#ccc';
                ctx.lineWidth = 2;
                ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
            }
        }
        
        // –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞
        ctx.fillStyle = platform.color;
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        
        // –ü–∏–∫—Å–µ–ª–∏ –Ω–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ
        ctx.fillStyle = gameState.isRedMode ? '#ff6666' : '#ccc';
        for (let i = 0; i < 6; i++) {
            ctx.fillRect(platform.x + 8 + i * 14, platform.y + 4, 8, 3);
        }
        
        // –ú—è—á
        ctx.fillStyle = ball.color;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = gameState.isRedMode ? '#ff0000' : '#888';
        ctx.beginPath();
        ctx.arc(ball.x - 2, ball.y - 2, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // –ü—É–ª–∏ –≤ –∫—Ä–∞—Å–Ω–æ–º —Ä–µ–∂–∏–º–µ
        if (gameState.isRedMode) {
            for (let bullet of bullets) {
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                
                ctx.fillStyle = '#ff6666';
                ctx.fillRect(bullet.x + 2, bullet.y + 2, bullet.width - 4, bullet.height - 4);
            }
            
            if (gameState.screenShake > 0) {
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.15)';
                ctx.lineWidth = 1;
                
                for (let x = 0; x < canvas.width; x += 25) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y < canvas.height; y += 25) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
        }
        
        // –ú–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω–∞—è –æ—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        if (window.showWallInfo) {
            ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`‚Üî ${newRightWall - newLeftWall}px`, canvas.width / 2, 15);
        }
        
        ctx.restore();
    };
    
    console.log("‚úÖ –§—É–Ω–∫—Ü–∏—è draw() –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –¥–ª—è —Ç–æ–Ω–∫–∏—Ö —Å–µ—Ä—ã—Ö —Å—Ç–µ–Ω");

    // 4. –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –ø–æ–∑–∏—Ü–∏–∏ –æ–±—ä–µ–∫—Ç–æ–≤ —Å —É—á–µ—Ç–æ–º —Ç–æ–ª—â–∏–Ω—ã —Å—Ç–µ–Ω
    const wallThickness = 2;
    
    if (ball.x - ball.radius < newLeftWall + wallThickness) {
        ball.x = newLeftWall + wallThickness + ball.radius;
        ball.speedX = Math.abs(ball.speedX);
        console.log(`‚öΩ –ú—è—á —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω –æ—Ç –ª–µ–≤–æ–π —Å—Ç–µ–Ω—ã: x=${ball.x.toFixed(1)}`);
    }
    
    if (ball.x + ball.radius > newRightWall - wallThickness) {
        ball.x = newRightWall - wallThickness - ball.radius;
        ball.speedX = -Math.abs(ball.speedX);
        console.log(`‚öΩ –ú—è—á —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω –æ—Ç –ø—Ä–∞–≤–æ–π —Å—Ç–µ–Ω—ã: x=${ball.x.toFixed(1)}`);
    }
    
    if (platform.x < newLeftWall + wallThickness) {
        platform.x = newLeftWall + wallThickness;
        console.log(`üõπ –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∞ –æ—Ç –ª–µ–≤–æ–π —Å—Ç–µ–Ω—ã: x=${platform.x}`);
    }
    
    if (platform.x + platform.width > newRightWall - wallThickness) {
        platform.x = newRightWall - wallThickness - platform.width;
        console.log(`üõπ –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∞ –æ—Ç –ø—Ä–∞–≤–æ–π —Å—Ç–µ–Ω—ã: x=${platform.x}`);
    }

    // 5. –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –≤–≤–æ–¥–∞ –¥–ª—è –Ω–æ–≤—ã—Ö –≥—Ä–∞–Ω–∏—Ü
    const originalHandleMouseMove = handleMouseMove;
    const originalHandleTouchMove = handleTouchMove;
    
    handleMouseMove = function(e) {
        if (!gameState.isRunning || gameState.gameOver) return;
        
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        let mouseX = (e.clientX - rect.left) * scaleX;
        let mouseY = (e.clientY - rect.top) * scaleY;
        
        const maxY = canvas.height / 2 + 30;
        const minX = newLeftWall + wallThickness + platform.width / 2;
        const maxX = newRightWall - wallThickness - platform.width / 2;
        
        mouseX = Math.max(minX, Math.min(maxX, mouseX));
        mouseY = Math.max(maxY, Math.min(canvas.height - platform.height / 2, mouseY));
        
        if (platform.isDragging) {
            platform.x = mouseX - platform.width / 2;
            platform.y = mouseY - platform.height / 2;
        }
    };
    
    handleTouchMove = function(e) {
        e.preventDefault();
        if (!gameState.isRunning || gameState.gameOver) return;
        
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const touch = e.touches[0];
        let touchX = (touch.clientX - rect.left) * scaleX;
        let touchY = (touch.clientY - rect.top) * scaleY;
        
        const maxY = canvas.height / 2 + 30;
        const minX = newLeftWall + wallThickness + platform.width / 2;
        const maxX = newRightWall - wallThickness - platform.width / 2;
        
        touchX = Math.max(minX, Math.min(maxX, touchX));
        touchY = Math.max(maxY, Math.min(canvas.height - platform.height / 2, touchY));
        
        platform.x = touchX - platform.width / 2;
        platform.y = touchY - platform.height / 2;
        
        launchBall();
    };
    
    console.log("‚úÖ –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –≤–≤–æ–¥–∞ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –¥–ª—è –Ω–æ–≤—ã—Ö –≥—Ä–∞–Ω–∏—Ü");

    // 6. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Å—ë –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
    window.originalUpdate = originalUpdate;
    window.originalDraw = originalDraw;
    window.originalHandleMouseMove = originalHandleMouseMove;
    window.originalHandleTouchMove = originalHandleTouchMove;
    window.narrowedLeftWall = newLeftWall;
    window.narrowedRightWall = newRightWall;
    window.wallThickness = wallThickness;
    window.areWallsNarrowed = true;
    window.showWallInfo = true; // –ú–æ–∂–Ω–æ –æ—Ç–∫–ª—é—á–∏—Ç—å: window.showWallInfo = false
    
    console.log("üéâ –°–¢–ï–ù–´ –£–°–ü–ï–®–ù–û –°–£–ñ–ï–ù–´!");
    console.log(`‚ú® –¢–µ–ø–µ—Ä—å –ø–æ–ª–µ –Ω–∞ ${narrowingAmount * 2}px —É–∂–µ (${originalWidth}px ‚Üí ${newRightWall - newLeftWall}px)`);
    console.log(`üé® –°—Ç–µ–Ω—ã: —Ç–æ–Ω–∫–∏–µ (${wallThickness}px) —Å–µ—Ä—ã–µ (#333333) –∫–∞–∫ –≤–µ—Ä—Ö/–Ω–∏–∑`);
    console.log("=".repeat(60));
    
    // 7. –ù–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞
    window.draw();
    
    return {
        success: true,
        leftWall: newLeftWall,
        rightWall: newRightWall,
        width: newRightWall - newLeftWall,
        wallThickness: wallThickness,
        wallColor: '#333333'
    };
}

        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            let mouseX = (e.clientX - rect.left) * scaleX;
            let mouseY = (e.clientY - rect.top) * scaleY;
            
            if (mouseX >= platform.x && mouseX <= platform.x + platform.width &&
                mouseY >= platform.y && mouseY <= platform.y + platform.height) {
                platform.isDragging = true;
            }
            
            launchBall();
        }

        function handleMouseUp() {
            platform.isDragging = false;
        }

        function startGame() {
            if (bgMusic && bgMusic.oscillator) {
                bgMusic.oscillator.stop();
            }
            if (redModeAudio) {
                redModeAudio.pause();
                redModeAudio.currentTime = 0;
            }
            
            gameState = {
                isRunning: true,
                brokenBricks: 0,
                totalBricks: 25,
                isRedMode: false,
                gameOver: false,
                screenShake: 0
            };
            
            platform = {
                x: 340,
                y: 530,
                width: 100,
                height: 15,
                color: '#fff',
                isDragging: false
            };
            
            ball = {
                x: 390,
                y: 290,
                radius: 8,
                speedX: 0,
                speedY: 0,
                color: '#fff',
                launched: false
            };
            
            bullets = [];
            
            initBricks();
            
            endScreen.style.display = 'none';
            
            if (soundEnabled) {
                bgMusic = createBackgroundMusic();
                bgMusic.gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
            }
            
            gameLoop();
        }

        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);
        
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleTouchMove(e);
        });
        canvas.addEventListener('touchend', handleMouseUp);

        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 10, 780);
            const maxHeight = Math.min(window.innerHeight - 10, 580);
            
            const scale = Math.min(maxWidth / 780, maxHeight / 580);
            
            canvas.style.width = (780 * scale) + 'px';
            canvas.style.height = (580 * scale) + 'px';
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        initAudio();
        startGame();
        narrowSideWalls(); // –í—Å—ë —Å–¥–µ–ª–∞–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏!
        
        // –ü—Ä–æ—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –º—É–∑—ã–∫–∏ –ø—Ä–∏ –∫–ª–∏–∫–µ
function tryPlayRedMusic() {
    if (window.needToPlayRedMusic && redModeAudio && gameState.isRedMode) {
        redModeAudio.play().then(() => {
            window.needToPlayRedMusic = false;
        }).catch(e => {
            // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É
        });
    }
}

// –í–µ—à–∞–µ–º –Ω–∞ –∫–ª–∏–∫–∏ –∏ —Ç–∞–ø—ã
document.addEventListener('click', tryPlayRedMusic);
document.addEventListener('touchstart', tryPlayRedMusic);
canvas.addEventListener('click', tryPlayRedMusic);
canvas.addEventListener('touchstart', tryPlayRedMusic);

    </script>
</body>
</html>